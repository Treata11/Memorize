{\rtf1\ansi\ansicpg1252\cocoartf2638
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Bold;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red252\green95\blue163;\red31\green31\blue36;\red255\green255\blue255;
\red208\green168\blue255;\red161\green103\blue230;\red208\green191\blue105;\red155\green35\blue147;\red255\green255\blue255;
\red0\green0\blue0;\red11\green79\blue121;\red15\green104\blue160;\red57\green0\blue160;\red28\green70\blue74;
\red50\green109\blue116;\red28\green0\blue207;\red108\green54\blue169;\red65\green161\blue192;\red158\green241\blue221;
\red103\green183\blue164;\red103\green183\blue164;\red158\green241\blue221;\red93\green216\blue255;\red208\green168\blue255;
\red161\green103\blue230;}
{\*\expandedcolortbl;;\csgenericrgb\c98839\c37355\c63833;\csgenericrgb\c12054\c12284\c14131;\csgenericrgb\c100000\c100000\c100000\c85000;
\csgenericrgb\c81681\c65692\c99927;\csgenericrgb\c63137\c40392\c90196;\csgenericrgb\c81498\c74939\c41233;\csgenericrgb\c60759\c13753\c57628;\csgenericrgb\c100000\c100000\c100000;
\csgenericrgb\c0\c0\c0\c85000;\csgenericrgb\c4314\c30980\c47451;\csgenericrgb\c5882\c40784\c62745;\csgenericrgb\c22454\c0\c62803;\csgenericrgb\c10981\c27276\c28869;
\csgenericrgb\c19418\c42935\c45455;\csgenericrgb\c11000\c0\c81000;\csgenericrgb\c42190\c21278\c66379;\csgenericrgb\c25490\c63137\c75294;\csgenericrgb\c62145\c94386\c86819;
\csgenericrgb\c40392\c71765\c64314;\csgenericrgb\c40538\c71705\c64209;\csgenericrgb\c61961\c94510\c86667;\csgenericrgb\c36295\c84643\c99897;\csgenericrgb\c81569\c65882\c100000;
\csgenericrgb\c63232\c40219\c90115;}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 professor Paul Hegarty.\
\
Assets.xcassets is the storage for the media used in creating the app.\
\
\
struct ContentView: View \{					Everytime the ContentView struct is called, the value of body is executed and returned.\
	var body: some View \{				some View ~ Text \
		return Text("Hello, World!") 		Text() function is a struct itself, looking like      struct Text: View \{ ...\}\
			.padding()				Using default values for modifier  functions is advised for multiplatform apps\
	\}\
\}\
\
\
struct ContentView: View \{\
	var body: some View \{\
		return ZStack(content: \{			content label is a view builder function, ZStack is a view combiner\
\
\
\
\
//We'll always use local variables for a function or a variable that is being called serval times in both structs and classes.\
\
\
\
\
\
onTapGesture(perform: \{\} )						It is a view modifier that takes a function as argeument label\
\
//E very View in swiftUI (structs etc) are immutable. When sth is change in the logic of the app, the entire UI is rebuilt through a process made possible by MVVM\
//Adding @State var variable:    makes a pointer to somewhere in memory where the actual variable is created, @State vars are mutable wherever they're created\
//Hold Option and click on any type to see the documentation.\
//Array, String, Set and any storage types are structs\
// Use ```id: \\.self``` to make the whole struct identifiable.\
//call code snippets via $<name_of_the_snippet> \
//```Button(action \{\}, label\{\})``` is a viewbuilder to add buttons to the UI\
//SFsymbols are prebuilt images in every apple device, to recall them: ```image(systemName: " ")```\
\
//LazyVGrid() let's you specify a number of columns and builds as much as rows as needed, vice versa for LazyHGrid()\
//Lazy phrase means this view builder is lazy to access the body vars but when necessary. \
LazyVGrid(colomn: GridItem[ .fixed(200)], GridItem[ .flexible()] \
\
\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf2 \cb3 let
\f2\b0 \cf4  shape = \cf5 RoundedRectangle\cf4 (\cf6 cornerRadius\cf4 : \cf7 13\cf4 )\
//cornerRadius is an initializer, inits are functions that are called when creating a struct or class.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 \cb1 \
import Foundation    //foundation is the struct for pure swift file\
\
\
MemoryGame \
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf8 \cb9 struct
\f2\b0 \cf10  \cf11 MemoryGame\cf10 <CardContent> \{\
    
\f1\b \cf8 private
\f2\b0 \cf10 (
\f1\b \cf8 set
\f2\b0 \cf10 ) 
\f1\b \cf8 var
\f2\b0 \cf10  \cf12 cards\cf10 : \cf13 Array\cf10 <\cf14 Card\cf10 >\
    \
    
\f1\b \cf8 func
\f2\b0 \cf10  \cf12 choose\cf10 (\cf12 _\cf10  card: \cf14 Card\cf10 ) -> \cf13 Void\cf10  \{\
        \
    \}\
    \
    
\f1\b \cf8 init
\f2\b0 \cf10 (\cf12 numberOfPairsOfCards\cf10 : \cf13 Int\cf10 , \cf12 creatCardContent\cf10 : (\cf13 Int\cf10 ) -> CardContent) \{\
        \cf15 cards\cf10  = \cf13 Array\cf10 <\cf14 Card\cf10 >()\
        \
        
\f1\b \cf8 for
\f2\b0 \cf10  pairIndex 
\f1\b \cf8 in
\f2\b0 \cf10  \cf16 0\cf10 ..<numberOfPairsOfCards \{\
            
\f1\b \cf8 let
\f2\b0 \cf10  content = creatCardContent(pairIndex)\
            \cf15 cards\cf10 .\cf17 append\cf10 (\cf14 Card\cf10 (content: content, id: pairIndex*\cf16 2\cf10 ))\
            \cf15 cards\cf10 .\cf17 append\cf10 (\cf14 Card\cf10 (content: content, id: pairIndex*\cf16 2\cf10 +\cf16 1\cf10 ))\
            \}\
        \}\
    \
    
\f1\b \cf8 struct
\f2\b0 \cf10  \cf11 Card\cf10 : \cf13 Identifiable\cf10  \{\
        
\f1\b \cf8 var
\f2\b0 \cf10  \cf12 isFaceUp\cf10 : \cf13 Bool\cf10  = 
\f1\b \cf8 true
\f2\b0 \cf10 \
        
\f1\b \cf8 var
\f2\b0 \cf10  \cf12 isMatched\cf10 : \cf13 Bool\cf10  = 
\f1\b \cf8 false
\f2\b0 \cf10 \
        
\f1\b \cf8 var
\f2\b0 \cf10  \cf12 content\cf10 : CardContent\
        
\f1\b \cf8 var
\f2\b0 \cf10  \cf12 id\cf10 : \cf13 Int\cf10 \
    \}\
\} \
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 \cb1 ViewModel:\
The ViewModel is part of the UI, not View\
It is best to be named after the job it has to do. In this case: EmojiMemoryGame.swift\
\
Inheritance & Behavior in Classes:\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf8 \cb9 class
\f2\b0 \cf10  \cf11 EmojiMemoryGame\cf10 : MySuperClass, BehavesLike \{\
\}\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 \cb1 In some cases MV is just a simple intermediary (network sql data base etc) but in our app it creates its own version of the model within the class. S o it's true to say that VM is a truth source for the model in certain circumstances,
\f2 \cf10 \cb9 \

\f0 \cf0 \cb1 "ViewModel is the gateKeeper" It's the VM's job to protect the model of the ViewModel from ill-behaving Views or anything else that has access to the model.\
 \
Private access Control:\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf8 \cb9 private
\f2\b0 \cf10  
\f1\b \cf8 var
\f2\b0 \cf10  \cf12 model\cf10 : \cf14 MemoryGame\cf10 <\cf13 String\cf10 > = \cf15 creatMemoryGame\cf10 ()\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0 \cf0 \cb1 Private restricts any mutation and observation to the model of the VM but the VM itself,\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf8 \cb9 private
\f2\b0 \cf10 (
\f1\b \cf8 set
\f2\b0 \cf10 ) 
\f0 \cf0 \cb1 on the other hand only restricts changes and mutation to the model of the VM but observation is allowed.\
It is still possible to create a private var for VM and give observation access to the view.\
Our model is a struct itself, we can pass that struct to our VM inside a closure for a variable. Frankly everytime that function is executed, we'll get a new copy of our model struct in the MV. it is shown below:\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f2 \cf4 \cb3      
\f1\b \cf2 private
\f2\b0 \cf4  
\f1\b \cf2 var
\f2\b0 \cf4  \cf18 model\cf4 : \cf19 MemoryGame\cf4 <\cf5 String\cf4 > = \cf20 creatMemoryGame\cf4 ()\
    \
    
\f1\b \cf2 var
\f2\b0 \cf4  \cf18 cards\cf4 : \cf5 Array\cf4 <\cf19 MemoryGame\cf4 <\cf5 String\cf4 >.\cf19 Card\cf4 > \{\
        
\f1\b \cf2 return
\f2\b0 \cf4  \cf21 model\cf4 .\cf21 cards\cf4 \
    \}\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f0 \cf0 \cb1 It is the same as we declared a private(set) var for the model\
\
\
If a struct is a type of a variable in the class (our VM variables in our case), we need to have an initializer and not use the free init that is available in structs. We need to create an identifiable init for our struct if it is used as a type in a class or anything that doesn't accept free inits (only structs accept variables with no values on the behalf of their free init capability).\
An init is created for this purpose on line 16 of the MemoryGame (model).\
\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf2 \cb3 static
\f2\b0 \cf4  
\f1\b \cf2 func\
static
\f2\b0 \cf4  
\f1\b \cf2 let\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f0\b0 \cf0 \cb1 static functions are called type functions and static constants and vars are called type properties.\
\
Demoware coding is required for training purposes!\
\
\
In the View's code there's always going to be a property with the content of the View Model like 
\f1\b \cf2 \cb3 let
\f2\b0 \cf4  \cf18 viewModel\cf4 : \cf22 \cb3 EmojiMemoryGame
\f0 \cf0 \cb1 \
It's recommended not to be called viewModel as shown here.\
We're going to do this wherever the ContentView struct is called as in the app itself, it was called as shown below: (MemorizeApp)\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf2 \cb3 import
\f2\b0 \cf4  SwiftUI\
\

\f1\b \cf2 @main
\f2\b0 \cf4 \

\f1\b \cf2 struct
\f2\b0 \cf4  \cf23 \cb3 MemorizeApp\cf4 \cb3 : \cf24 \cb3 App\cf4 \cb3  \{\
    
\f1\b \cf2 let
\f2\b0 \cf4  \cf18 game\cf4  = \cf22 \cb3 EmojiMemoryGame\cf4 \cb3 ()\
    \
    
\f1\b \cf2 var
\f2\b0 \cf4  \cf18 body\cf4 : 
\f1\b \cf2 some
\f2\b0 \cf4  \cf24 \cb3 Scene\cf4 \cb3  \{\
        \cf5 WindowGroup\cf4  \{\
            \cf19 ContentView\cf4 (\cf20 viewModel\cf4 : \cf21 game\cf4 )\
        \}\
    \}\
\}\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f0 \cf0 \cb1 \
so we are going to implement our viewModel to the top of the app struct.\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf2 \cb3 let
\f2\b0 \cf4  \cf18 game\cf4  = \cf22 \cb3 EmojiMemoryGame\cf4 \cb3 ()
\f0 \cf0 \cb1 \
We've made it a let constant because offcourse the EmojiMemoryGame() is a class so when making a let, the let is going to be a pointer to the class, the class will change as we want to but the pointer will always stay unchanged.\
\
We've passed the viewmodel: game for the initialization of the ContentView, \
(ContentView preview code is updated with our let game and vieModel was passed with game (our ViewModel) )\

\f1\b \cf2 \cb3 struct
\f2\b0 \cf4  \cf23 \cb3 ContentView_Previews\cf4 \cb3 : \cf24 \cb3 PreviewProvider\cf4 \cb3  \{\
    
\f1\b \cf2 static
\f2\b0 \cf4  
\f1\b \cf2 var
\f2\b0 \cf4  \cf18 previews\cf4 : 
\f1\b \cf2 some
\f2\b0 \cf4  \cf24 \cb3 View\cf4 \cb3  \{\
        
\f1\b \cf2 let
\f2\b0 \cf4  game = \cf22 \cb3 EmojiMemoryGame\cf4 \cb3 ()\
        \cf5 Group\cf4  \{\
            \cf19 ContentView\cf4 (\cf20 viewModel\cf4 : game)\
                .\cf6 preferredColorScheme\cf4 (.\cf25 \cb3 dark\cf4 \cb3 )\
            \cf19 ContentView\cf4 (\cf20 viewModel\cf4 : game)\
                .\cf6 preferredColorScheme\cf4 (.\cf25 \cb3 dark\cf4 \cb3 )\
        \}\
        \cf19 ContentView\cf4 (\cf20 viewModel\cf4 : game)\
            .\cf6 preferredColorScheme\cf4 (.\cf25 \cb3 light\cf4 \cb3 )\
        \}\
    \}\
\}\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f0 \cf0 \cb1 \
\
\
\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf2 \cb3 struct
\f2\b0 \cf4  \cf23 \cb3 CardView\cf4 \cb3 : \cf24 \cb3 View\cf4 \cb3  \{\
    
\f1\b \cf2 let
\f2\b0 \cf4  \cf18 card\cf4 : \cf19 MemoryGame\cf4 <\cf5 String\cf4 >.\cf19 Card\cf4 \
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f0 \cf0 \cb1 We've created a card constant and we didn't give the whole card type that we had declared in our model. this is highly recommended:\
When you build a View, only pass into it the minimum it needs to do its job.\
CardView job is to build a UI only to represent a Card that is in the model, so we only passed it a card.\
\
declaring variables in a struct using other variable or functions in the structs, makes a new copy of that!\
to mutate a func or var in a struct, we have to let the world know by saying mutating var or func etc.\
\pard\tx593\pardeftab593\pardirnatural\partightenfactor0

\f1\b \cf2 \cb3 struct
\f2\b0 \cf4  \cf23 \cb3 MemoryGame\cf4 \cb3 <CardContent> \{\
    
\f1\b \cf2 private
\f2\b0 \cf4 (
\f1\b \cf2 set
\f2\b0 \cf4 ) 
\f1\b \cf2 var
\f2\b0 \cf4  \cf18 cards\cf4 : \cf5 Array\cf4 <\cf22 \cb3 Card\cf4 \cb3 >\
    \
    
\f1\b \cf2 mutating
\f2\b0 \cf4  
\f1\b \cf2 func
\f2\b0 \cf4  \cf18 choose\cf4 (\cf18 _\cf4  card: \cf22 \cb3 Card\cf4 \cb3 ) -> \cf5 Void\cf4  \{\
        
\f1\b \cf2 let
\f2\b0 \cf4  chosenIndex = \cf20 index\cf4 (\cf20 of\cf4 : card)\
        \cf21 cards\cf4 [\cf5 Int\cf4 (chosenIndex)].\cf21 isFaceUp\cf4 .\cf6 toggle\cf4 ()\
    \}\
}